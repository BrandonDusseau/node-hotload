exec   = require \child_process .exec
PATH   = require \path
fs     = require \fs
colors = require \colors
crypto = require 'crypto'

stack = require \callsite

l = -> console.log "--".yellow.bold, it

resolveCalledFilename = let
	MODULE = require("module")
	(request, stackLevel)->
		moduleFilename = stack()[stackLevel].getFileName()
		MODULE._resolveFilename(request, require.cache[moduleFilename])

# function getCalledModule
# 	moduleFilename = stack()[1].getFileName()
# 	require.cache[moduleFilename]

# x = resolveCalledFilename("./testModule")

sha1 = (string)->crypto.createHash \sha1 .update string .digest \hex

hashSums     = {}
fileWatchers = {}

headStr = -> it.substr(0,7)

onFileChange = require \./onFileChange.js

onFileChange2 = (path,callback)->

	function hashSum
		if fs.existsSync path
			sha1 fs.readFileSync path
		else
			l "warning, #path is not available anymore!".red.bold
			hashSums[path]

	function isDifferentHash
		h = hashSum!
		if h is not hashSums[path]
			l "#path #{headStr(h)} --> #{headStr(hashSums[path])}"
			hashSums[path] = h
			true
		else
			false

	function init
		if not fs.existsSync path
			l "Path #path does not exists"
			false
		else
			hashSums[path] || hashSums[path] = hashSum!
			fileWatchers[path] = fs.watch path, (event)->
				l event
				if event is 'change' and isDifferentHash!
					callback path

					# on some systems change event is called twice
					# so wait for 1000ms
					# fileWatchers[path].close!
					# setTimeout (-> init!), 1000

	if typeof callback is \function
		init!
		return {stop: (-> fileWatchers[path].close!), reload: init}
	else
		throw new Error "No callback for onFileChange"


# path, [function callback]
module.exports = (path,callback)->

	# if not callback? and typeof not_watch is \function
	# 	callback := not_watch
	# 	not_watch := false

	absPath = resolveCalledFilename path, 2
	mainDir = PATH.dirname require.main.filename
	relPath = absPath.replace //#{mainDir}//, ''

	# first load
	if not require.cache[absPath]?

		l "Loading #relPath"

		_module = require absPath

		if typeof _module is not \object
			l "[warn] Hotload only works with objects, #relPath will not be reloaded"
			return _module
		else
			_module.hlInit?!

			callback?(_module)

			onFileChange absPath, ->
				# module.exports absPath,not_watch,callback
				module.exports absPath,callback

			return _module

	# reload
	else

		l "Reloading #relPath"

		absTmpPath = absPath + ".tmp"

		# replace reference in cache
		require.cache[absTmpPath] = require.cache[absPath]
		delete require.cache[absPath]

		# require copied module
		_module = require absPath

		# flip back
		require.cache[absPath] = require.cache[absTmpPath]
		delete require.cache[absTmpPath]

		## replace all references from require.cache[absPath] with require.cache[absTmpPath]
		# for k in require.cache[absTmpPath]
		# 	require.cache[absPath][k] = require.cache[absTmpPath][k]

		# unload module and remove all previous properties
		require.cache[absPath].exports.hlUnload?! # unload

		# set all properties to null
		for k in require.cache[absPath].exports
			require.cache[absPath].exports[k] = null # garbage collect

		# explicitly execute garbage collector
		global.gc?!

		for k in _module
			require.cache[absPath].exports[k] = _module[k]

		require.cache[absPath].exports.hlInit?! # initialize
		
		callback?(require.cache[absPath].exports)

		return require.cache[absPath].exports

